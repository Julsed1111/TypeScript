//Задача 1 _________________________________________________________

//Визначте інтерфейс, який використовує сигнатуру індексу з типами об'єднання. Наприклад, тип значення для кожного ключа може
//бути число | рядок.

interface VariantIndexable {
  [key: string]: number | string;
}

//Задача 2 _________________________________________________________

//Створіть інтерфейс, у якому типи значень у сигнатурі індексу є функціями. Ключами можуть бути рядки, а значеннями — функції,
//які приймають будь-які аргументи.

interface FunctionIndexed {
  [key: string]: (...rest: any[]) => any;
}

//Задача 3 _________________________________________________________

//Опишіть інтерфейс, який використовує сигнатуру індексу для опису об'єкта, подібного до масиву. Ключі повинні бути числами,
//а значення - певного типу.

type variant = string | number;

interface NumericIndexedObject {
  [key: number]: variant;
}

//Задача 4 _________________________________________________________

//Створіть інтерфейс з певними властивостями та індексною сигнатурою. Наприклад, ви можете мати властивості типу
//name: string та індексну сигнатуру для додаткових динамічних властивостей.

interface IndexedProperties {
  name: string;
  [key: string]: string | number | boolean;
}

//Задача 5 _________________________________________________________

//Створіть два інтерфейси, один з індексною сигнатурою, а інший розширює перший, додаючи специфічні властивості.

interface IndexProperties {
  [key: string]: string | number;
}

interface SpecificProperties extends IndexProperties {
  name: string;
  age: number;
}

//Задача 6 _________________________________________________________

//Напишіть функцію, яка отримує об'єкт з індексною сигнатурою і перевіряє, чи відповідають значення певних ключів певним
//критеріям (наприклад, чи всі значення є числами).

interface KeyValuePairs {
  [key: string]: number;
}

function areValuesNumbers(obj: KeyValuePairs, keys: string[]): boolean {
  return keys.every((key) => typeof obj[key] === "number");
}
